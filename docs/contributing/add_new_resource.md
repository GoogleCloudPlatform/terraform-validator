# Adding support for a new resource

## terraform-validator vs config-validator

At its core, terraform-validator is a thin layer on top of [config-validator](https://github.com/GoogleCloudPlatform/config-validator), a shared library that takes in a [policy library](https://github.com/GoogleCloudPlatform/policy-library) and a set of [CAI assets](https://cloud.google.com/asset-inventory/docs/overview) and reports back any violations of the specified policies.

terraform-validator consumes a Terraform plan and uses it to build CAI Assets, which then get run through config-validator. These built Assets only exist locally, in memory.

### Adding a new constraint template

If an existing [bundle](https://github.com/GoogleCloudPlatform/policy-library/blob/master/docs/index.md#policy-bundles) (for example, [CIS v1.1](https://github.com/GoogleCloudPlatform/policy-library/blob/master/docs/bundles/cis-v1.1.md)) doesn't support a check you need, please consider contributing a [new constraint template](https://github.com/GoogleCloudPlatform/policy-library/blob/master/docs/constraint_template_authoring.md) to the policy-library repository.

### Getting a terraform resource name from a GCP resource name

The first step in determining if a GCP resource is supported is to figure out the name of the corresponding Terraform resource. You can often do this by searching for the GCP resource name in the [Terraform google provider documentation](https://registry.terraform.io/providers/hashicorp/google/latest/docs).

## How to add support for a new resource

A resource is "supported" by terraform-validator if it has an entry in [`converters/google/resources/resource_converters.go`](https://github.com/GoogleCloudPlatform/terraform-validator/blob/main/converters/google/resources/resource_converters.go). For example, you could search resource_converters.go for [`google_compute_disk`](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_disk) to see if that resource is supported.

Adding support for a resource has four steps:

1. Make changes to [Magic Modules](https://github.com/GoogleCloudPlatform/magic-modules) to add or modify resource conversion code. Run [Magic Modules generation](https://github.com/GoogleCloudPlatform/magic-modules/#generating-terraform-validator) to update your local terraform validator.
2. Add tests for the new resource to terraform-validator.
3. Make PRs for Magic Modules & terraform-validator with your changes.

Each of these is discussed in more detail below.

**Note**: terraform-validator can only support resources that are supported by the GA terraform provider, not beta resources.

### 1. Magic Modules

Magic Modules uses a shared code base to generate terraform-validator and the [google](https://github.com/hashicorp/terraform-provider-google) and [google-beta](https://github.com/hashicorp/terraform-provider-google-beta) Terraform providers.
Most Terraform resources are represented as [yaml files which are grouped by product](https://github.com/GoogleCloudPlatform/magic-modules/tree/master/mmv1/products).
Each product has an `api.yaml` file (which defines the basic API schema) and a `terraform.yaml` file (which defines any terraform-specific overrides.)
A `terraform.yaml` file can specify `exclude_validator: true` on a resource to skip terraform-validator autogeneration, or `exclude_resource: true` to skip autogeneration for both terraform-validator and the providers.

Auto-generating terraform-validator code based on yaml files is strongly preferred. If this does not automatically add an entry to `resource_converters.go`, you can manually add an entry to [`resource_converters.go.erb`](https://github.com/GoogleCloudPlatform/magic-modules/blob/master/mmv1/templates/validator/resource_converters.go.erb) using the autogenerated resource converter function.

#### Handwritten converters
If an autogenerated converter is not possible, you can instead place a handwritten file in the [`magic-modules/mmv1/third_party/validator` folder](https://github.com/GoogleCloudPlatform/magic-modules/tree/master/mmv1/third_party/validator).
Most resources will only need a resource converter with a conversion func. For the Resource resource within Product, this might look like:

```golang
// The type comes from https://cloud.google.com/asset-inventory/docs/supported-asset-types
const ProductResourceAssetType string = "compute.googleapis.com/Route"

func resourceConverterProductResource() ResourceConverter {
	return ResourceConverter{
		AssetType: ProductResourceAssetType,
		Convert:   GetProductResourceCaiObject,

	}
}

func GetProductResourceCaiObject(d TerraformResourceData, config *Config) ([]Asset, error) {
	// This function does basic conversion of a Terraform resource to a CAI Asset.
	// The asset path (name) will substitute in variables from the Terraform resource.
	// The format should match what is specified at https://cloud.google.com/asset-inventory/docs/supported-asset-types
	name, err := assetName(d, config, "//whatever.googleapis.com/projects/{{project}}/whatevers/{{name}}")
	if err != nil {
		return []Asset{}, err
	}
	if obj, err := GetProductResourceApiObject(d, config); err == nil {
		return []Asset{{
			Name: name,
			Type: ProductResourceAssetType,
			Resource: &AssetResource{
				Version:              "v1",  // or whatever the correct version is
				DiscoveryDocumentURI: "https://www.googleapis.com/path/to/rest/api/docs",
				DiscoveryName:        "Whatever",  // The term used to refer to this resource by the official documentation
				Data:                 obj,
			},
		}}, nil
	} else {
		return []Asset{}, err
	}
}

func GetProductResourceApiObject(d TerraformResourceData, config *Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})

	// copy values from the terraform resource to obj
	// return any errors encountered
	// ...

	return obj, nil
}

```

You will also need to add an entry to [`resource_converters.go.erb`](https://github.com/GoogleCloudPlatform/magic-modules/blob/master/mmv1/templates/validator/resource_converters.go.erb), which is used to generate [`converters/google/resources/resource_converters.go`](https://github.com/GoogleCloudPlatform/terraform-validator/blob/main/converters/google/resources/resource_converters.go). Each entry in `resource_converters.go.erb` maps a terraform resource name to a function that returns a ResourceConverter - in this case:

```golang
// ...
"google_product_resource": resourceConverterProductResource(),
// ...
```

To generate terraform-validator code locally, run the following from the root of the `magic-modules` repository:

```
cd mmv1
make validator OUTPUT_PATH="/path/to/your/terraform-validator"
```

You can then run `make test` inside your terraform-validator repository to make sure that your code compiles and passes basic unit tests.

### 2. Adding new Terraform Validator tests

Terraform Validator tests require setting up a few files in [`testdata/templates`](https://github.com/GoogleCloudPlatform/terraform-validator/tree/master/testdata/templates). Using the previous example, these files would be:

- example_product_resource.tf
  - A basic terraform file that creates the minimum resources necessary for the google_product_resource resource.
- example_product_resource.tfplan.json
  - A plan json file generated from example_product_resource.tf.
- example_product_resource.json
  - The results of running [`terraform-validator convert example_product_resource.tfplan.json`](./index.md#convert-command)

It's easiest to set up a [test project](../tutorial.md) to create the initial versions of these files. Once you have initial versions completed, you need to make the following replacements in the .tfplan.json and .json files:

1. Test project ancestry => `{{.Ancestry}}/project/{{.Provider.project}}`
1. Test project id (without ancestry) => `{{.Provider.project}}`
1. Test project number => `{{.Project.Number}}`
1. Test organization id => `{{.OrgID}}`
1. Test folder id => `{{.FolderID}}`
1. Test billing account => `{{.Project.BillingAccountName}}`

Add your new test cases to [test/cli_test.go](https://github.com/GoogleCloudPlatform/terraform-validator/blob/c1295c541897e1357eb3e4d93a88d7083ff41c90/test/cli_test.go#L52) and [test/read_test.go](https://github.com/GoogleCloudPlatform/terraform-validator/blob/c1295c541897e1357eb3e4d93a88d7083ff41c90/test/read_test.go#L24). Add the name of your files (i.e. `example_product_resource` to the lists of test cases in each file.

Now [run your tests](./index.md#testing) and make sure they pass locally before proceeding. (But you can also go ahead and open PRs if you're running into issues you can't figure out how to resolve.)

### 3. Make PRs

Now that you have your code working locally, open PRs for [Magic Modules](https://github.com/GoogleCloudPlatform/magic-modules) and terraform-validator.

For the Magic Modules PR, the most important check is `terraform-validator-test` - the other checks only matter if you're also making changes to the terraform provider. 

If any of the checks on your terraform validator PR are failing, make sure you can run the unit and integration tests successfully locally.

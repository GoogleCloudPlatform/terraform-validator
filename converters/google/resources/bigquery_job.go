// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"reflect"
	"regexp"
)

var (
	bigqueryDatasetRegexp = regexp.MustCompile("projects/(.+)/datasets/(.+)")
	bigqueryTableRegexp   = regexp.MustCompile("projects/(.+)/datasets/(.+)/tables/(.+)")
)

const BigQueryJobAssetType string = "bigquery.googleapis.com/Job"

func resourceConverterBigQueryJob() ResourceConverter {
	return ResourceConverter{
		AssetType: BigQueryJobAssetType,
		Convert:   GetBigQueryJobCaiObject,
	}
}

func GetBigQueryJobCaiObject(d TerraformResourceData, config *Config) ([]Asset, error) {
	name, err := assetName(d, config, "//bigquery.googleapis.com/projects/{{project}}/jobs/{{job_id}}?location={{location}}")
	if err != nil {
		return []Asset{}, err
	}
	if obj, err := GetBigQueryJobApiObject(d, config); err == nil {
		return []Asset{{
			Name: name,
			Type: BigQueryJobAssetType,
			Resource: &AssetResource{
				Version:              "v2",
				DiscoveryDocumentURI: "https://www.googleapis.com/discovery/v1/apis/bigquery/v2/rest",
				DiscoveryName:        "Job",
				Data:                 obj,
			},
		}}, nil
	} else {
		return []Asset{}, err
	}
}

func GetBigQueryJobApiObject(d TerraformResourceData, config *Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})
	configurationProp, err := expandBigQueryJobConfiguration(nil, d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("configuration"); !isEmptyValue(reflect.ValueOf(configurationProp)) && (ok || !reflect.DeepEqual(v, configurationProp)) {
		obj["configuration"] = configurationProp
	}
	jobReferenceProp, err := expandBigQueryJobJobReference(nil, d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("job_reference"); !isEmptyValue(reflect.ValueOf(jobReferenceProp)) && (ok || !reflect.DeepEqual(v, jobReferenceProp)) {
		obj["jobReference"] = jobReferenceProp
	}

	return resourceBigQueryJobEncoder(d, config, obj)
}

func resourceBigQueryJobEncoder(d TerraformResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	project, err := getProject(d, meta.(*Config))
	if err != nil {
		return nil, err
	}
	obj["jobReference"].(map[string]interface{})["project"] = project
	return obj, nil
}

func expandBigQueryJobConfiguration(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	transformed := make(map[string]interface{})
	transformedJobType, err := expandBigQueryJobConfigurationJobType(d.Get("job_type"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJobType); val.IsValid() && !isEmptyValue(val) {
		transformed["jobType"] = transformedJobType
	}

	transformedJobTimeoutMs, err := expandBigQueryJobConfigurationJobTimeoutMs(d.Get("job_timeout_ms"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJobTimeoutMs); val.IsValid() && !isEmptyValue(val) {
		transformed["jobTimeoutMs"] = transformedJobTimeoutMs
	}

	transformedLabels, err := expandBigQueryJobConfigurationLabels(d.Get("labels"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !isEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedQuery, err := expandBigQueryJobConfigurationQuery(d.Get("query"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedQuery); val.IsValid() && !isEmptyValue(val) {
		transformed["query"] = transformedQuery
	}

	transformedLoad, err := expandBigQueryJobConfigurationLoad(d.Get("load"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLoad); val.IsValid() && !isEmptyValue(val) {
		transformed["load"] = transformedLoad
	}

	transformedCopy, err := expandBigQueryJobConfigurationCopy(d.Get("copy"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCopy); val.IsValid() && !isEmptyValue(val) {
		transformed["copy"] = transformedCopy
	}

	transformedExtract, err := expandBigQueryJobConfigurationExtract(d.Get("extract"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExtract); val.IsValid() && !isEmptyValue(val) {
		transformed["extract"] = transformedExtract
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationJobType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationJobTimeoutMs(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLabels(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandBigQueryJobConfigurationQuery(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedQuery, err := expandBigQueryJobConfigurationQueryQuery(original["query"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedQuery); val.IsValid() && !isEmptyValue(val) {
		transformed["query"] = transformedQuery
	}

	transformedDestinationTable, err := expandBigQueryJobConfigurationQueryDestinationTable(original["destination_table"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationTable); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationTable"] = transformedDestinationTable
	}

	transformedUserDefinedFunctionResources, err := expandBigQueryJobConfigurationQueryUserDefinedFunctionResources(original["user_defined_function_resources"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserDefinedFunctionResources); val.IsValid() && !isEmptyValue(val) {
		transformed["userDefinedFunctionResources"] = transformedUserDefinedFunctionResources
	}

	transformedCreateDisposition, err := expandBigQueryJobConfigurationQueryCreateDisposition(original["create_disposition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateDisposition); val.IsValid() && !isEmptyValue(val) {
		transformed["createDisposition"] = transformedCreateDisposition
	}

	transformedWriteDisposition, err := expandBigQueryJobConfigurationQueryWriteDisposition(original["write_disposition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWriteDisposition); val.IsValid() && !isEmptyValue(val) {
		transformed["writeDisposition"] = transformedWriteDisposition
	}

	transformedDefaultDataset, err := expandBigQueryJobConfigurationQueryDefaultDataset(original["default_dataset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefaultDataset); val.IsValid() && !isEmptyValue(val) {
		transformed["defaultDataset"] = transformedDefaultDataset
	}

	transformedPriority, err := expandBigQueryJobConfigurationQueryPriority(original["priority"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPriority); val.IsValid() && !isEmptyValue(val) {
		transformed["priority"] = transformedPriority
	}

	transformedAllowLargeResults, err := expandBigQueryJobConfigurationQueryAllowLargeResults(original["allow_large_results"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowLargeResults); val.IsValid() && !isEmptyValue(val) {
		transformed["allowLargeResults"] = transformedAllowLargeResults
	}

	transformedUseQueryCache, err := expandBigQueryJobConfigurationQueryUseQueryCache(original["use_query_cache"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUseQueryCache); val.IsValid() && !isEmptyValue(val) {
		transformed["useQueryCache"] = transformedUseQueryCache
	}

	transformedFlattenResults, err := expandBigQueryJobConfigurationQueryFlattenResults(original["flatten_results"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFlattenResults); val.IsValid() && !isEmptyValue(val) {
		transformed["flattenResults"] = transformedFlattenResults
	}

	transformedMaximumBillingTier, err := expandBigQueryJobConfigurationQueryMaximumBillingTier(original["maximum_billing_tier"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaximumBillingTier); val.IsValid() && !isEmptyValue(val) {
		transformed["maximumBillingTier"] = transformedMaximumBillingTier
	}

	transformedMaximumBytesBilled, err := expandBigQueryJobConfigurationQueryMaximumBytesBilled(original["maximum_bytes_billed"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaximumBytesBilled); val.IsValid() && !isEmptyValue(val) {
		transformed["maximumBytesBilled"] = transformedMaximumBytesBilled
	}

	transformedUseLegacySql, err := expandBigQueryJobConfigurationQueryUseLegacySql(original["use_legacy_sql"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["useLegacySql"] = transformedUseLegacySql
	}

	transformedParameterMode, err := expandBigQueryJobConfigurationQueryParameterMode(original["parameter_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParameterMode); val.IsValid() && !isEmptyValue(val) {
		transformed["parameterMode"] = transformedParameterMode
	}

	transformedSchemaUpdateOptions, err := expandBigQueryJobConfigurationQuerySchemaUpdateOptions(original["schema_update_options"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSchemaUpdateOptions); val.IsValid() && !isEmptyValue(val) {
		transformed["schemaUpdateOptions"] = transformedSchemaUpdateOptions
	}

	transformedDestinationEncryptionConfiguration, err := expandBigQueryJobConfigurationQueryDestinationEncryptionConfiguration(original["destination_encryption_configuration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationEncryptionConfiguration); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationEncryptionConfiguration"] = transformedDestinationEncryptionConfiguration
	}

	transformedScriptOptions, err := expandBigQueryJobConfigurationQueryScriptOptions(original["script_options"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScriptOptions); val.IsValid() && !isEmptyValue(val) {
		transformed["scriptOptions"] = transformedScriptOptions
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationQueryQuery(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryDestinationTable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProjectId := original["project_id"]
	if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !isEmptyValue(val) {
		transformed["projectId"] = transformedProjectId
	}

	transformedDatasetId := original["dataset_id"]
	if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetId"] = transformedDatasetId
	}

	transformedTableId := original["table_id"]
	if val := reflect.ValueOf(transformedTableId); val.IsValid() && !isEmptyValue(val) {
		transformed["tableId"] = transformedTableId
	}

	if parts := bigqueryTableRegexp.FindStringSubmatch(transformedTableId.(string)); parts != nil {
		transformed["projectId"] = parts[1]
		transformed["datasetId"] = parts[2]
		transformed["tableId"] = parts[3]
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationQueryUserDefinedFunctionResources(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedResourceUri, err := expandBigQueryJobConfigurationQueryUserDefinedFunctionResourcesResourceUri(original["resource_uri"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResourceUri); val.IsValid() && !isEmptyValue(val) {
			transformed["resourceUri"] = transformedResourceUri
		}

		transformedInlineCode, err := expandBigQueryJobConfigurationQueryUserDefinedFunctionResourcesInlineCode(original["inline_code"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInlineCode); val.IsValid() && !isEmptyValue(val) {
			transformed["inlineCode"] = transformedInlineCode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBigQueryJobConfigurationQueryUserDefinedFunctionResourcesResourceUri(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryUserDefinedFunctionResourcesInlineCode(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryCreateDisposition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryWriteDisposition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryDefaultDataset(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProjectId := original["project_id"]
	if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !isEmptyValue(val) {
		transformed["projectId"] = transformedProjectId
	}

	transformedDatasetId := original["dataset_id"]
	if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetId"] = transformedDatasetId
	}

	if parts := bigqueryDatasetRegexp.FindStringSubmatch(transformedDatasetId.(string)); parts != nil {
		transformed["projectId"] = parts[1]
		transformed["datasetId"] = parts[2]
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationQueryPriority(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryAllowLargeResults(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryUseQueryCache(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryFlattenResults(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryMaximumBillingTier(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryMaximumBytesBilled(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryUseLegacySql(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryParameterMode(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQuerySchemaUpdateOptions(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryDestinationEncryptionConfiguration(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKmsKeyName, err := expandBigQueryJobConfigurationQueryDestinationEncryptionConfigurationKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !isEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	transformedKmsKeyVersion, err := expandBigQueryJobConfigurationQueryDestinationEncryptionConfigurationKmsKeyVersion(original["kms_key_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyVersion); val.IsValid() && !isEmptyValue(val) {
		transformed["kmsKeyVersion"] = transformedKmsKeyVersion
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationQueryDestinationEncryptionConfigurationKmsKeyName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryDestinationEncryptionConfigurationKmsKeyVersion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryScriptOptions(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedStatementTimeoutMs, err := expandBigQueryJobConfigurationQueryScriptOptionsStatementTimeoutMs(original["statement_timeout_ms"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStatementTimeoutMs); val.IsValid() && !isEmptyValue(val) {
		transformed["statementTimeoutMs"] = transformedStatementTimeoutMs
	}

	transformedStatementByteBudget, err := expandBigQueryJobConfigurationQueryScriptOptionsStatementByteBudget(original["statement_byte_budget"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStatementByteBudget); val.IsValid() && !isEmptyValue(val) {
		transformed["statementByteBudget"] = transformedStatementByteBudget
	}

	transformedKeyResultStatement, err := expandBigQueryJobConfigurationQueryScriptOptionsKeyResultStatement(original["key_result_statement"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKeyResultStatement); val.IsValid() && !isEmptyValue(val) {
		transformed["keyResultStatement"] = transformedKeyResultStatement
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationQueryScriptOptionsStatementTimeoutMs(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryScriptOptionsStatementByteBudget(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationQueryScriptOptionsKeyResultStatement(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoad(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSourceUris, err := expandBigQueryJobConfigurationLoadSourceUris(original["source_uris"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceUris); val.IsValid() && !isEmptyValue(val) {
		transformed["sourceUris"] = transformedSourceUris
	}

	transformedDestinationTable, err := expandBigQueryJobConfigurationLoadDestinationTable(original["destination_table"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationTable); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationTable"] = transformedDestinationTable
	}

	transformedCreateDisposition, err := expandBigQueryJobConfigurationLoadCreateDisposition(original["create_disposition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateDisposition); val.IsValid() && !isEmptyValue(val) {
		transformed["createDisposition"] = transformedCreateDisposition
	}

	transformedWriteDisposition, err := expandBigQueryJobConfigurationLoadWriteDisposition(original["write_disposition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWriteDisposition); val.IsValid() && !isEmptyValue(val) {
		transformed["writeDisposition"] = transformedWriteDisposition
	}

	transformedNullMarker, err := expandBigQueryJobConfigurationLoadNullMarker(original["null_marker"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNullMarker); val.IsValid() && !isEmptyValue(val) {
		transformed["nullMarker"] = transformedNullMarker
	}

	transformedFieldDelimiter, err := expandBigQueryJobConfigurationLoadFieldDelimiter(original["field_delimiter"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFieldDelimiter); val.IsValid() && !isEmptyValue(val) {
		transformed["fieldDelimiter"] = transformedFieldDelimiter
	}

	transformedSkipLeadingRows, err := expandBigQueryJobConfigurationLoadSkipLeadingRows(original["skip_leading_rows"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSkipLeadingRows); val.IsValid() && !isEmptyValue(val) {
		transformed["skipLeadingRows"] = transformedSkipLeadingRows
	}

	transformedEncoding, err := expandBigQueryJobConfigurationLoadEncoding(original["encoding"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEncoding); val.IsValid() && !isEmptyValue(val) {
		transformed["encoding"] = transformedEncoding
	}

	transformedQuote, err := expandBigQueryJobConfigurationLoadQuote(original["quote"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedQuote); val.IsValid() && !isEmptyValue(val) {
		transformed["quote"] = transformedQuote
	}

	transformedMaxBadRecords, err := expandBigQueryJobConfigurationLoadMaxBadRecords(original["max_bad_records"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxBadRecords); val.IsValid() && !isEmptyValue(val) {
		transformed["maxBadRecords"] = transformedMaxBadRecords
	}

	transformedAllowQuotedNewlines, err := expandBigQueryJobConfigurationLoadAllowQuotedNewlines(original["allow_quoted_newlines"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowQuotedNewlines); val.IsValid() && !isEmptyValue(val) {
		transformed["allowQuotedNewlines"] = transformedAllowQuotedNewlines
	}

	transformedSourceFormat, err := expandBigQueryJobConfigurationLoadSourceFormat(original["source_format"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceFormat); val.IsValid() && !isEmptyValue(val) {
		transformed["sourceFormat"] = transformedSourceFormat
	}

	transformedAllowJaggedRows, err := expandBigQueryJobConfigurationLoadAllowJaggedRows(original["allow_jagged_rows"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAllowJaggedRows); val.IsValid() && !isEmptyValue(val) {
		transformed["allowJaggedRows"] = transformedAllowJaggedRows
	}

	transformedIgnoreUnknownValues, err := expandBigQueryJobConfigurationLoadIgnoreUnknownValues(original["ignore_unknown_values"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIgnoreUnknownValues); val.IsValid() && !isEmptyValue(val) {
		transformed["ignoreUnknownValues"] = transformedIgnoreUnknownValues
	}

	transformedProjectionFields, err := expandBigQueryJobConfigurationLoadProjectionFields(original["projection_fields"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProjectionFields); val.IsValid() && !isEmptyValue(val) {
		transformed["projectionFields"] = transformedProjectionFields
	}

	transformedAutodetect, err := expandBigQueryJobConfigurationLoadAutodetect(original["autodetect"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutodetect); val.IsValid() && !isEmptyValue(val) {
		transformed["autodetect"] = transformedAutodetect
	}

	transformedSchemaUpdateOptions, err := expandBigQueryJobConfigurationLoadSchemaUpdateOptions(original["schema_update_options"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSchemaUpdateOptions); val.IsValid() && !isEmptyValue(val) {
		transformed["schemaUpdateOptions"] = transformedSchemaUpdateOptions
	}

	transformedTimePartitioning, err := expandBigQueryJobConfigurationLoadTimePartitioning(original["time_partitioning"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimePartitioning); val.IsValid() && !isEmptyValue(val) {
		transformed["timePartitioning"] = transformedTimePartitioning
	}

	transformedDestinationEncryptionConfiguration, err := expandBigQueryJobConfigurationLoadDestinationEncryptionConfiguration(original["destination_encryption_configuration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationEncryptionConfiguration); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationEncryptionConfiguration"] = transformedDestinationEncryptionConfiguration
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationLoadSourceUris(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadDestinationTable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProjectId := original["project_id"]
	if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !isEmptyValue(val) {
		transformed["projectId"] = transformedProjectId
	}

	transformedDatasetId := original["dataset_id"]
	if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetId"] = transformedDatasetId
	}

	transformedTableId := original["table_id"]
	if val := reflect.ValueOf(transformedTableId); val.IsValid() && !isEmptyValue(val) {
		transformed["tableId"] = transformedTableId
	}

	if parts := bigqueryTableRegexp.FindStringSubmatch(transformedTableId.(string)); parts != nil {
		transformed["projectId"] = parts[1]
		transformed["datasetId"] = parts[2]
		transformed["tableId"] = parts[3]
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationLoadCreateDisposition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadWriteDisposition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadNullMarker(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadFieldDelimiter(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadSkipLeadingRows(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadEncoding(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadQuote(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadMaxBadRecords(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadAllowQuotedNewlines(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadSourceFormat(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadAllowJaggedRows(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadIgnoreUnknownValues(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadProjectionFields(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadAutodetect(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadSchemaUpdateOptions(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadTimePartitioning(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandBigQueryJobConfigurationLoadTimePartitioningType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !isEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedExpirationMs, err := expandBigQueryJobConfigurationLoadTimePartitioningExpirationMs(original["expiration_ms"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExpirationMs); val.IsValid() && !isEmptyValue(val) {
		transformed["expirationMs"] = transformedExpirationMs
	}

	transformedField, err := expandBigQueryJobConfigurationLoadTimePartitioningField(original["field"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedField); val.IsValid() && !isEmptyValue(val) {
		transformed["field"] = transformedField
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationLoadTimePartitioningType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadTimePartitioningExpirationMs(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadTimePartitioningField(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadDestinationEncryptionConfiguration(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKmsKeyName, err := expandBigQueryJobConfigurationLoadDestinationEncryptionConfigurationKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !isEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	transformedKmsKeyVersion, err := expandBigQueryJobConfigurationLoadDestinationEncryptionConfigurationKmsKeyVersion(original["kms_key_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyVersion); val.IsValid() && !isEmptyValue(val) {
		transformed["kmsKeyVersion"] = transformedKmsKeyVersion
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationLoadDestinationEncryptionConfigurationKmsKeyName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationLoadDestinationEncryptionConfigurationKmsKeyVersion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationCopy(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSourceTables, err := expandBigQueryJobConfigurationCopySourceTables(original["source_tables"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceTables); val.IsValid() && !isEmptyValue(val) {
		transformed["sourceTables"] = transformedSourceTables
	}

	transformedDestinationTable, err := expandBigQueryJobConfigurationCopyDestinationTable(original["destination_table"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationTable); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationTable"] = transformedDestinationTable
	}

	transformedCreateDisposition, err := expandBigQueryJobConfigurationCopyCreateDisposition(original["create_disposition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCreateDisposition); val.IsValid() && !isEmptyValue(val) {
		transformed["createDisposition"] = transformedCreateDisposition
	}

	transformedWriteDisposition, err := expandBigQueryJobConfigurationCopyWriteDisposition(original["write_disposition"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWriteDisposition); val.IsValid() && !isEmptyValue(val) {
		transformed["writeDisposition"] = transformedWriteDisposition
	}

	transformedDestinationEncryptionConfiguration, err := expandBigQueryJobConfigurationCopyDestinationEncryptionConfiguration(original["destination_encryption_configuration"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationEncryptionConfiguration); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationEncryptionConfiguration"] = transformedDestinationEncryptionConfiguration
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationCopySourceTables(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedProjectId := original["project_id"]
		if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !isEmptyValue(val) {
			transformed["projectId"] = transformedProjectId
		}

		transformedDatasetId := original["dataset_id"]
		if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
			transformed["datasetId"] = transformedDatasetId
		}

		transformedTableId := original["table_id"]
		if val := reflect.ValueOf(transformedTableId); val.IsValid() && !isEmptyValue(val) {
			transformed["tableId"] = transformedTableId
		}

		tableRef := regexp.MustCompile("projects/(.+)/datasets/(.+)/tables/(.+)")
		if parts := tableRef.FindStringSubmatch(transformedTableId.(string)); parts != nil {
			transformed["projectId"] = parts[1]
			transformed["datasetId"] = parts[2]
			transformed["tableId"] = parts[3]
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBigQueryJobConfigurationCopyDestinationTable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProjectId := original["project_id"]
	if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !isEmptyValue(val) {
		transformed["projectId"] = transformedProjectId
	}

	transformedDatasetId := original["dataset_id"]
	if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetId"] = transformedDatasetId
	}

	transformedTableId := original["table_id"]
	if val := reflect.ValueOf(transformedTableId); val.IsValid() && !isEmptyValue(val) {
		transformed["tableId"] = transformedTableId
	}

	if parts := bigqueryTableRegexp.FindStringSubmatch(transformedTableId.(string)); parts != nil {
		transformed["projectId"] = parts[1]
		transformed["datasetId"] = parts[2]
		transformed["tableId"] = parts[3]
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationCopyCreateDisposition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationCopyWriteDisposition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationCopyDestinationEncryptionConfiguration(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKmsKeyName, err := expandBigQueryJobConfigurationCopyDestinationEncryptionConfigurationKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !isEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	transformedKmsKeyVersion, err := expandBigQueryJobConfigurationCopyDestinationEncryptionConfigurationKmsKeyVersion(original["kms_key_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyVersion); val.IsValid() && !isEmptyValue(val) {
		transformed["kmsKeyVersion"] = transformedKmsKeyVersion
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationCopyDestinationEncryptionConfigurationKmsKeyName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationCopyDestinationEncryptionConfigurationKmsKeyVersion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtract(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDestinationUris, err := expandBigQueryJobConfigurationExtractDestinationUris(original["destination_uris"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationUris); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationUris"] = transformedDestinationUris
	}

	transformedPrintHeader, err := expandBigQueryJobConfigurationExtractPrintHeader(original["print_header"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrintHeader); val.IsValid() && !isEmptyValue(val) {
		transformed["printHeader"] = transformedPrintHeader
	}

	transformedFieldDelimiter, err := expandBigQueryJobConfigurationExtractFieldDelimiter(original["field_delimiter"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFieldDelimiter); val.IsValid() && !isEmptyValue(val) {
		transformed["fieldDelimiter"] = transformedFieldDelimiter
	}

	transformedDestinationFormat, err := expandBigQueryJobConfigurationExtractDestinationFormat(original["destination_format"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationFormat); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationFormat"] = transformedDestinationFormat
	}

	transformedCompression, err := expandBigQueryJobConfigurationExtractCompression(original["compression"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCompression); val.IsValid() && !isEmptyValue(val) {
		transformed["compression"] = transformedCompression
	}

	transformedUseAvroLogicalTypes, err := expandBigQueryJobConfigurationExtractUseAvroLogicalTypes(original["use_avro_logical_types"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUseAvroLogicalTypes); val.IsValid() && !isEmptyValue(val) {
		transformed["useAvroLogicalTypes"] = transformedUseAvroLogicalTypes
	}

	transformedSourceTable, err := expandBigQueryJobConfigurationExtractSourceTable(original["source_table"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceTable); val.IsValid() && !isEmptyValue(val) {
		transformed["sourceTable"] = transformedSourceTable
	}

	transformedSourceModel, err := expandBigQueryJobConfigurationExtractSourceModel(original["source_model"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceModel); val.IsValid() && !isEmptyValue(val) {
		transformed["sourceModel"] = transformedSourceModel
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationExtractDestinationUris(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtractPrintHeader(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtractFieldDelimiter(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtractDestinationFormat(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtractCompression(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtractUseAvroLogicalTypes(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtractSourceTable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProjectId := original["project_id"]
	if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !isEmptyValue(val) {
		transformed["projectId"] = transformedProjectId
	}

	transformedDatasetId := original["dataset_id"]
	if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetId"] = transformedDatasetId
	}

	transformedTableId := original["table_id"]
	if val := reflect.ValueOf(transformedTableId); val.IsValid() && !isEmptyValue(val) {
		transformed["tableId"] = transformedTableId
	}

	if parts := bigqueryTableRegexp.FindStringSubmatch(transformedTableId.(string)); parts != nil {
		transformed["projectId"] = parts[1]
		transformed["datasetId"] = parts[2]
		transformed["tableId"] = parts[3]
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationExtractSourceModel(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedProjectId, err := expandBigQueryJobConfigurationExtractSourceModelProjectId(original["project_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProjectId); val.IsValid() && !isEmptyValue(val) {
		transformed["projectId"] = transformedProjectId
	}

	transformedDatasetId, err := expandBigQueryJobConfigurationExtractSourceModelDatasetId(original["dataset_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetId"] = transformedDatasetId
	}

	transformedModelId, err := expandBigQueryJobConfigurationExtractSourceModelModelId(original["model_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModelId); val.IsValid() && !isEmptyValue(val) {
		transformed["modelId"] = transformedModelId
	}

	return transformed, nil
}

func expandBigQueryJobConfigurationExtractSourceModelProjectId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtractSourceModelDatasetId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobConfigurationExtractSourceModelModelId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobJobReference(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	transformed := make(map[string]interface{})
	transformedJobId, err := expandBigQueryJobJobReferenceJobId(d.Get("job_id"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJobId); val.IsValid() && !isEmptyValue(val) {
		transformed["jobId"] = transformedJobId
	}

	transformedLocation, err := expandBigQueryJobJobReferenceLocation(d.Get("location"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocation); val.IsValid() && !isEmptyValue(val) {
		transformed["location"] = transformedLocation
	}

	return transformed, nil
}

func expandBigQueryJobJobReferenceJobId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandBigQueryJobJobReferenceLocation(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

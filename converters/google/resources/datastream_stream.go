// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"context"
	"fmt"
	"reflect"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceDatastreamStreamCustomDiffFunc(diff TerraformResourceDiff) error {
	if diff.HasChange("desired_state") {
		old, new := diff.GetChange("desired_state")
		oldState := old.(string)
		newState := new.(string)

		if isNewResource(diff) {
			if newState != "NOT_STARTED" && newState != "RUNNING" {
				return fmt.Errorf("`desired_state` can only be set to `NOT_STARTED` or `RUNNING` when creating a new Stream")
			}
		} else {
			if newState == "NOT_STARTED" && oldState != newState {
				return fmt.Errorf("Field `desired_state` cannot be changed to `NOT_STARTED` for an already-created Stream")
			}

			if oldState == "NOT_STARTED" && newState != "RUNNING" {
				return fmt.Errorf("Field `desired_state` can only be set to `RUNNING` from `NOT_STARTED`")
			}

			if newState != "RUNNING" && newState != "PAUSED" {
				return fmt.Errorf("`desired_state` can only be set to `RUNNING` or `PAUSED` when updating a Stream")
			}
		}
	}
	return nil
}
func resourceDatastreamStreamCustomDiff(_ context.Context, diff *schema.ResourceDiff, meta interface{}) error {
	// separate func to allow unit testing
	return resourceDatastreamStreamCustomDiffFunc(diff)
}

const DatastreamStreamAssetType string = "datastream.googleapis.com/Stream"

func resourceConverterDatastreamStream() ResourceConverter {
	return ResourceConverter{
		AssetType: DatastreamStreamAssetType,
		Convert:   GetDatastreamStreamCaiObject,
	}
}

func GetDatastreamStreamCaiObject(d TerraformResourceData, config *Config) ([]Asset, error) {
	name, err := assetName(d, config, "//datastream.googleapis.com/projects/{{project}}/locations/{{location}}/streams/{{stream_id}}")
	if err != nil {
		return []Asset{}, err
	}
	if obj, err := GetDatastreamStreamApiObject(d, config); err == nil {
		return []Asset{{
			Name: name,
			Type: DatastreamStreamAssetType,
			Resource: &AssetResource{
				Version:              "v1",
				DiscoveryDocumentURI: "https://www.googleapis.com/discovery/v1/apis/datastream/v1/rest",
				DiscoveryName:        "Stream",
				Data:                 obj,
			},
		}}, nil
	} else {
		return []Asset{}, err
	}
}

func GetDatastreamStreamApiObject(d TerraformResourceData, config *Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})
	labelsProp, err := expandDatastreamStreamLabels(d.Get("labels"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("labels"); !isEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	displayNameProp, err := expandDatastreamStreamDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("display_name"); !isEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	sourceConfigProp, err := expandDatastreamStreamSourceConfig(d.Get("source_config"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("source_config"); !isEmptyValue(reflect.ValueOf(sourceConfigProp)) && (ok || !reflect.DeepEqual(v, sourceConfigProp)) {
		obj["sourceConfig"] = sourceConfigProp
	}
	destinationConfigProp, err := expandDatastreamStreamDestinationConfig(d.Get("destination_config"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("destination_config"); !isEmptyValue(reflect.ValueOf(destinationConfigProp)) && (ok || !reflect.DeepEqual(v, destinationConfigProp)) {
		obj["destinationConfig"] = destinationConfigProp
	}
	backfillAllProp, err := expandDatastreamStreamBackfillAll(d.Get("backfill_all"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("backfill_all"); ok || !reflect.DeepEqual(v, backfillAllProp) {
		obj["backfillAll"] = backfillAllProp
	}
	backfillNoneProp, err := expandDatastreamStreamBackfillNone(d.Get("backfill_none"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("backfill_none"); ok || !reflect.DeepEqual(v, backfillNoneProp) {
		obj["backfillNone"] = backfillNoneProp
	}
	customerManagedEncryptionKeyProp, err := expandDatastreamStreamCustomerManagedEncryptionKey(d.Get("customer_managed_encryption_key"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("customer_managed_encryption_key"); !isEmptyValue(reflect.ValueOf(customerManagedEncryptionKeyProp)) && (ok || !reflect.DeepEqual(v, customerManagedEncryptionKeyProp)) {
		obj["customerManagedEncryptionKey"] = customerManagedEncryptionKeyProp
	}

	return resourceDatastreamStreamEncoder(d, config, obj)
}

func resourceDatastreamStreamEncoder(d TerraformResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	if d.HasChange("desired_state") {
		obj["state"] = d.Get("desired_state")
	}
	return obj, nil
}

func expandDatastreamStreamLabels(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandDatastreamStreamDisplayName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfig(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSourceConnectionProfile, err := expandDatastreamStreamSourceConfigSourceConnectionProfile(original["source_connection_profile"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceConnectionProfile); val.IsValid() && !isEmptyValue(val) {
		transformed["sourceConnectionProfile"] = transformedSourceConnectionProfile
	}

	transformedMysqlSourceConfig, err := expandDatastreamStreamSourceConfigMysqlSourceConfig(original["mysql_source_config"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["mysqlSourceConfig"] = transformedMysqlSourceConfig
	}

	return transformed, nil
}

func expandDatastreamStreamSourceConfigSourceConnectionProfile(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfig(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIncludeObjects, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjects(original["include_objects"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIncludeObjects); val.IsValid() && !isEmptyValue(val) {
		transformed["includeObjects"] = transformedIncludeObjects
	}

	transformedExcludeObjects, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjects(original["exclude_objects"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExcludeObjects); val.IsValid() && !isEmptyValue(val) {
		transformed["excludeObjects"] = transformedExcludeObjects
	}

	transformedMaxConcurrentCdcTasks, err := expandDatastreamStreamSourceConfigMysqlSourceConfigMaxConcurrentCdcTasks(original["max_concurrent_cdc_tasks"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["maxConcurrentCdcTasks"] = transformedMaxConcurrentCdcTasks
	}

	return transformed, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjects(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMysqlDatabases, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabases(original["mysql_databases"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMysqlDatabases); val.IsValid() && !isEmptyValue(val) {
		transformed["mysqlDatabases"] = transformedMysqlDatabases
	}

	return transformed, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabases(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDatabase, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesDatabase(original["database"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDatabase); val.IsValid() && !isEmptyValue(val) {
			transformed["database"] = transformedDatabase
		}

		transformedMysqlTables, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTables(original["mysql_tables"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMysqlTables); val.IsValid() && !isEmptyValue(val) {
			transformed["mysqlTables"] = transformedMysqlTables
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesDatabase(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTables(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedTable, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesTable(original["table"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTable); val.IsValid() && !isEmptyValue(val) {
			transformed["table"] = transformedTable
		}

		transformedMysqlColumns, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumns(original["mysql_columns"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMysqlColumns); val.IsValid() && !isEmptyValue(val) {
			transformed["mysqlColumns"] = transformedMysqlColumns
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesTable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumns(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedColumn, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsColumn(original["column"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedColumn); val.IsValid() && !isEmptyValue(val) {
			transformed["column"] = transformedColumn
		}

		transformedDataType, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsDataType(original["data_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataType); val.IsValid() && !isEmptyValue(val) {
			transformed["dataType"] = transformedDataType
		}

		transformedLength, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsLength(original["length"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLength); val.IsValid() && !isEmptyValue(val) {
			transformed["length"] = transformedLength
		}

		transformedCollation, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsCollation(original["collation"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCollation); val.IsValid() && !isEmptyValue(val) {
			transformed["collation"] = transformedCollation
		}

		transformedPrimaryKey, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsPrimaryKey(original["primary_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrimaryKey); val.IsValid() && !isEmptyValue(val) {
			transformed["primaryKey"] = transformedPrimaryKey
		}

		transformedNullable, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsNullable(original["nullable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNullable); val.IsValid() && !isEmptyValue(val) {
			transformed["nullable"] = transformedNullable
		}

		transformedOrdinalPosition, err := expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsOrdinalPosition(original["ordinal_position"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOrdinalPosition); val.IsValid() && !isEmptyValue(val) {
			transformed["ordinalPosition"] = transformedOrdinalPosition
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsColumn(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsDataType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsLength(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsCollation(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsPrimaryKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsNullable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsOrdinalPosition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjects(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMysqlDatabases, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabases(original["mysql_databases"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMysqlDatabases); val.IsValid() && !isEmptyValue(val) {
		transformed["mysqlDatabases"] = transformedMysqlDatabases
	}

	return transformed, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabases(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDatabase, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesDatabase(original["database"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDatabase); val.IsValid() && !isEmptyValue(val) {
			transformed["database"] = transformedDatabase
		}

		transformedMysqlTables, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTables(original["mysql_tables"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMysqlTables); val.IsValid() && !isEmptyValue(val) {
			transformed["mysqlTables"] = transformedMysqlTables
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesDatabase(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTables(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedTable, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesTable(original["table"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTable); val.IsValid() && !isEmptyValue(val) {
			transformed["table"] = transformedTable
		}

		transformedMysqlColumns, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumns(original["mysql_columns"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMysqlColumns); val.IsValid() && !isEmptyValue(val) {
			transformed["mysqlColumns"] = transformedMysqlColumns
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesTable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumns(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedColumn, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsColumn(original["column"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedColumn); val.IsValid() && !isEmptyValue(val) {
			transformed["column"] = transformedColumn
		}

		transformedDataType, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsDataType(original["data_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataType); val.IsValid() && !isEmptyValue(val) {
			transformed["dataType"] = transformedDataType
		}

		transformedLength, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsLength(original["length"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLength); val.IsValid() && !isEmptyValue(val) {
			transformed["length"] = transformedLength
		}

		transformedCollation, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsCollation(original["collation"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCollation); val.IsValid() && !isEmptyValue(val) {
			transformed["collation"] = transformedCollation
		}

		transformedPrimaryKey, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsPrimaryKey(original["primary_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrimaryKey); val.IsValid() && !isEmptyValue(val) {
			transformed["primaryKey"] = transformedPrimaryKey
		}

		transformedNullable, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsNullable(original["nullable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNullable); val.IsValid() && !isEmptyValue(val) {
			transformed["nullable"] = transformedNullable
		}

		transformedOrdinalPosition, err := expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsOrdinalPosition(original["ordinal_position"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOrdinalPosition); val.IsValid() && !isEmptyValue(val) {
			transformed["ordinalPosition"] = transformedOrdinalPosition
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsColumn(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsDataType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsLength(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsCollation(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsPrimaryKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsNullable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabasesMysqlTablesMysqlColumnsOrdinalPosition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamSourceConfigMysqlSourceConfigMaxConcurrentCdcTasks(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfig(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDestinationConnectionProfile, err := expandDatastreamStreamDestinationConfigDestinationConnectionProfile(original["destination_connection_profile"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationConnectionProfile); val.IsValid() && !isEmptyValue(val) {
		transformed["destinationConnectionProfile"] = transformedDestinationConnectionProfile
	}

	transformedGcsDestinationConfig, err := expandDatastreamStreamDestinationConfigGcsDestinationConfig(original["gcs_destination_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcsDestinationConfig); val.IsValid() && !isEmptyValue(val) {
		transformed["gcsDestinationConfig"] = transformedGcsDestinationConfig
	}

	transformedBigqueryDestinationConfig, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfig(original["bigquery_destination_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBigqueryDestinationConfig); val.IsValid() && !isEmptyValue(val) {
		transformed["bigqueryDestinationConfig"] = transformedBigqueryDestinationConfig
	}

	return transformed, nil
}

func expandDatastreamStreamDestinationConfigDestinationConnectionProfile(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigGcsDestinationConfig(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPath, err := expandDatastreamStreamDestinationConfigGcsDestinationConfigPath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !isEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedFileRotationMb, err := expandDatastreamStreamDestinationConfigGcsDestinationConfigFileRotationMb(original["file_rotation_mb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFileRotationMb); val.IsValid() && !isEmptyValue(val) {
		transformed["fileRotationMb"] = transformedFileRotationMb
	}

	transformedFileRotationInterval, err := expandDatastreamStreamDestinationConfigGcsDestinationConfigFileRotationInterval(original["file_rotation_interval"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFileRotationInterval); val.IsValid() && !isEmptyValue(val) {
		transformed["fileRotationInterval"] = transformedFileRotationInterval
	}

	transformedAvroFileFormat, err := expandDatastreamStreamDestinationConfigGcsDestinationConfigAvroFileFormat(original["avro_file_format"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["avroFileFormat"] = transformedAvroFileFormat
	}

	transformedJsonFileFormat, err := expandDatastreamStreamDestinationConfigGcsDestinationConfigJsonFileFormat(original["json_file_format"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJsonFileFormat); val.IsValid() && !isEmptyValue(val) {
		transformed["jsonFileFormat"] = transformedJsonFileFormat
	}

	return transformed, nil
}

func expandDatastreamStreamDestinationConfigGcsDestinationConfigPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigGcsDestinationConfigFileRotationMb(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigGcsDestinationConfigFileRotationInterval(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigGcsDestinationConfigAvroFileFormat(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDatastreamStreamDestinationConfigGcsDestinationConfigJsonFileFormat(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSchemaFileFormat, err := expandDatastreamStreamDestinationConfigGcsDestinationConfigJsonFileFormatSchemaFileFormat(original["schema_file_format"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSchemaFileFormat); val.IsValid() && !isEmptyValue(val) {
		transformed["schemaFileFormat"] = transformedSchemaFileFormat
	}

	transformedCompression, err := expandDatastreamStreamDestinationConfigGcsDestinationConfigJsonFileFormatCompression(original["compression"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCompression); val.IsValid() && !isEmptyValue(val) {
		transformed["compression"] = transformedCompression
	}

	return transformed, nil
}

func expandDatastreamStreamDestinationConfigGcsDestinationConfigJsonFileFormatSchemaFileFormat(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigGcsDestinationConfigJsonFileFormatCompression(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfig(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataFreshness, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfigDataFreshness(original["data_freshness"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataFreshness); val.IsValid() && !isEmptyValue(val) {
		transformed["dataFreshness"] = transformedDataFreshness
	}

	transformedSingleTargetDataset, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset(original["single_target_dataset"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSingleTargetDataset); val.IsValid() && !isEmptyValue(val) {
		transformed["singleTargetDataset"] = transformedSingleTargetDataset
	}

	transformedSourceHierarchyDatasets, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets(original["source_hierarchy_datasets"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSourceHierarchyDatasets); val.IsValid() && !isEmptyValue(val) {
		transformed["sourceHierarchyDatasets"] = transformedSourceHierarchyDatasets
	}

	return transformed, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfigDataFreshness(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDatasetId, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetDatasetId(original["dataset_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetId"] = transformedDatasetId
	}

	return transformed, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetDatasetId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDatasetTemplate, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate(original["dataset_template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatasetTemplate); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetTemplate"] = transformedDatasetTemplate
	}

	return transformed, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLocation, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateLocation(original["location"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocation); val.IsValid() && !isEmptyValue(val) {
		transformed["location"] = transformedLocation
	}

	transformedDatasetIdPrefix, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateDatasetIdPrefix(original["dataset_id_prefix"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatasetIdPrefix); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetIdPrefix"] = transformedDatasetIdPrefix
	}

	transformedKmsKeyName, err := expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !isEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateLocation(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateDatasetIdPrefix(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateKmsKeyName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAll(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMysqlExcludedObjects, err := expandDatastreamStreamBackfillAllMysqlExcludedObjects(original["mysql_excluded_objects"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMysqlExcludedObjects); val.IsValid() && !isEmptyValue(val) {
		transformed["mysqlExcludedObjects"] = transformedMysqlExcludedObjects
	}

	return transformed, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjects(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMysqlDatabases, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabases(original["mysql_databases"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMysqlDatabases); val.IsValid() && !isEmptyValue(val) {
		transformed["mysqlDatabases"] = transformedMysqlDatabases
	}

	return transformed, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabases(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedDatabase, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesDatabase(original["database"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDatabase); val.IsValid() && !isEmptyValue(val) {
			transformed["database"] = transformedDatabase
		}

		transformedMysqlTables, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTables(original["mysql_tables"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMysqlTables); val.IsValid() && !isEmptyValue(val) {
			transformed["mysqlTables"] = transformedMysqlTables
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesDatabase(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTables(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedTable, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesTable(original["table"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTable); val.IsValid() && !isEmptyValue(val) {
			transformed["table"] = transformedTable
		}

		transformedMysqlColumns, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumns(original["mysql_columns"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMysqlColumns); val.IsValid() && !isEmptyValue(val) {
			transformed["mysqlColumns"] = transformedMysqlColumns
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesTable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumns(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedColumn, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsColumn(original["column"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedColumn); val.IsValid() && !isEmptyValue(val) {
			transformed["column"] = transformedColumn
		}

		transformedDataType, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsDataType(original["data_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDataType); val.IsValid() && !isEmptyValue(val) {
			transformed["dataType"] = transformedDataType
		}

		transformedLength, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsLength(original["length"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLength); val.IsValid() && !isEmptyValue(val) {
			transformed["length"] = transformedLength
		}

		transformedCollation, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsCollation(original["collation"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCollation); val.IsValid() && !isEmptyValue(val) {
			transformed["collation"] = transformedCollation
		}

		transformedPrimaryKey, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsPrimaryKey(original["primary_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrimaryKey); val.IsValid() && !isEmptyValue(val) {
			transformed["primaryKey"] = transformedPrimaryKey
		}

		transformedNullable, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsNullable(original["nullable"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNullable); val.IsValid() && !isEmptyValue(val) {
			transformed["nullable"] = transformedNullable
		}

		transformedOrdinalPosition, err := expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsOrdinalPosition(original["ordinal_position"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOrdinalPosition); val.IsValid() && !isEmptyValue(val) {
			transformed["ordinalPosition"] = transformedOrdinalPosition
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsColumn(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsDataType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsLength(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsCollation(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsPrimaryKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsNullable(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillAllMysqlExcludedObjectsMysqlDatabasesMysqlTablesMysqlColumnsOrdinalPosition(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandDatastreamStreamBackfillNone(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandDatastreamStreamCustomerManagedEncryptionKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
